<?xml version="1.0" encoding="utf-8"?>
<!-- Minimal, UI-agnostic Preset Manager UI, consuming Rekal's Manager API -->
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
    xmlns:s="library://ns.adobe.com/flex/spark"
    xmlns:mx="library://ns.adobe.com/flex/mx"
    width="100%" height="100%">

    <fx:Metadata>
        [Style(name="headerStyle", type="String", inherit="no")]
        [Style(name="saveButtonStyle", type="String", inherit="no")]
        [Style(name="deleteButtonStyle", type="String", inherit="no")]
        [Style(name="vGap", type="Number", inherit="no")]
        [Style(name="hGap", type="Number", inherit="no")]
        [Style(name="paddingLeft", type="Number", inherit="no")]
        [Style(name="paddingTop", type="Number", inherit="no")]
        [Style(name="paddingRight", type="Number", inherit="no")]
        [Style(name="paddingBottom", type="Number", inherit="no")]
        [Style(name="padding", type="Number", inherit="no")]
    </fx:Metadata>

    <fx:Script>
        <![CDATA[
            import com.github.ciacob.asrekallibrary.Manager;
            import com.github.ciacob.asrekallibrary.Preset;
            import com.github.ciacob.asrekallibrary.events.PresetEvent;
            import spark.components.ComboBox;
            import mx.collections.ArrayCollection;
            
            /**
             * Set to `true` to have current selection preserved. past a Save operation.
             * By default, selection is preserved.
             */
            [Bindable]
            public var keepSelection:Boolean = true;
            
            /**
             * Set to `true` to have the built-in header shown. Set to `false` if you
             * intend to use your own header. By default, the header is visible.
             */
            [Bindable]
            public var showHeader:Boolean = true;
            
            /**
             * Asset(s) to populate the Delete button with, such as a String to use as
             * label, or, e.g., if the button skin permits it, an FXG class to use as an
             * icon.
             * Note: you can set a different button skin via `deleteButtonStyle`.
             */
            [Bindable]
            public var deleteButtonContent:* = "Delete";
            
            /**
             * Asset(s) to populate the Save button with, such as a String to use as
             * label, or, e.g., if the button skin permits it, an FXG class to use as an
             * icon.
             * Note: you can set a different button skin via `saveButtonStyle`.
             */
            [Bindable]
            public var saveButtonContent:* = "Save";
            
            /**
             * Text to use as the ComboBox prompt displayed when there is no item to
             * display (either existing or custom).
             */
            [Bindable]
            public var promptText:String = "Type to search or add presets";
            
            /**
             * Text to use as the component's header, provided it is visible.
             */
            [Bindable]
            public var headerText:String = "Presets";
            
            /**
             * Time before status message clears itself, in seconds. Set to 0 to disable.
             */
            [Bindable]
            public var statusTimeOut:int = 3;
            
            [Bindable]
            private var _presets:ArrayCollection = new ArrayCollection;
            
            [Bindable]
            private var _statusMsg:String = "";
            
            [Bindable]
            private var _numChars:uint = 40;
            
            private var _rawPresets:Vector.<Preset> = new Vector.<Preset>;
            
            private var _manager:Manager;
            
            private var _presetToPersist:Preset;
            
            private var _statusTimer:Timer;
            
            /**
             * Connects this UI component to a Manager instance. Connection is "hot",
             * meaning that the changes you operate on the Manager instance directly
             * will be reflected here in due time.
             *
             * Note: you MUST connect to a Manager in order to be able to use this
             * component.
             */
            public function initializeWith(manager:Manager):void {
                this._manager = manager;
                if (!_manager) {
                    return;
                };
                this._numChars = manager.labelMaxLength;
                _updateList();
            }
            
            /**
             * Sets status with a delay for auto-clearing itself.
             */
            private function _setStatus(msg:String):void {
                _statusMsg = msg;
                if (!statusTimeOut) {
                    return;
                }
                const onTimerComplete:Function = function():void {
                    _statusMsg = "";
                    _statusTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, onTimerComplete);
                    _statusTimer = null;
                };
                if (_statusTimer) {
                    _statusTimer.reset();
                }
                else {
                    _statusTimer = new Timer(statusTimeOut * 1000, 1);
                    _statusTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onTimerComplete);
                }
                _statusTimer.start();
            }
            
            /**
             * Causes buttons to become available based on specific criteria.
             */
            private function _updateButtons():void {
                const canDelete:Boolean = (presetList.selectedIndex > ComboBox.CUSTOM_SELECTED_ITEM &&
                        presetList.selectedItem &&
                        !presetList.selectedItem.readonly);
                const canSave:Boolean = !!presetList.selectedItem;
                deleteButton.enabled = canDelete;
                saveButton.enabled = canSave;
            }
            
            /**
             * Helper, trims a string. Returns an empty string for `null`.
             */
            private function _trim(str:String):String {
                if (!str) {
                    return '';
                }
                return str.replace(/^\s+|\s+$/g, '');
            }
            
            /**
             * Puts read-only presets firsts, alphabetically sorted, then the rest of the presets,
             * also alphabetically sorted.
             */
            private function _defaultSort(a:Preset, b:Preset):int {
                const byName:int = a.name.localeCompare(b.name);
                return (b.readonly as int) - (a.readonly as int) || byName;
            }
            
            /**
             * Causes the list to be asynchronously rebuilt, picking up all changes, and
             * optionally restoring previous selection.
             */
            private function _updateList():void {
                if (!_manager) {
                    return;
                };
                _manager.addEventListener(PresetEvent.LIST_COMPLETE, _onListComplete);
                _manager.listAsync(null, _defaultSort);
            }
            
            /**
             * Executed when the manager finished its asynchronous listing and we can start
             * repopulating the ComboBox. We cache received data for synchronous local lookups.
             */
            private function _onListComplete(e:PresetEvent):void {
                _manager.removeEventListener(PresetEvent.LIST_COMPLETE, _onListComplete);
                _presets.removeAll();
                _rawPresets = (e.data as Vector.<Preset>);
                if (_rawPresets) {
                    for (var i:int = 0; i < _rawPresets.length; i++) {
                        const preset:Preset = _rawPresets[i];
                        _presets.addItem(preset);
                    }
            
                    if (_presetToPersist && keepSelection) {
                        presetList.selectedItem = _presetToPersist;
                        _presetToPersist = null;
                        _updateButtons();
                    }
                }
            }
            
            /**
             * Executed when user clicks "Save".
             */
            private function _onSaveClick():void {
                if (!_manager || !presetList.selectedItem) {
                    return;
                }
            
                // A `PresetEvent.SAVING` event is dispatched when user clicks "Save". Its `data` is an Object
                // with a `commit()` closure. Client code must listen for this event and call the closure,
                // passing it the data to save (see `$set()` in class Manager for supported data types).
                dispatchEvent(new PresetEvent(PresetEvent.SAVING, {
                                commit: function(dataToSave:Object):void {
                                    if (!dataToSave) {
                                        return;
                                    }
                                    _manager.addEventListener(PresetEvent.SET_COMPLETE, _onSaved);
                                    _manager.$setAsync(dataToSave, presetList.selectedItem.name, true);
                                }
                            }, true));
            }
            
            /**
             * Executed when the manager has finished asynchronously storing client-provided data.
             */
            private function _onSaved(e:PresetEvent):void {
            
                // Safeguard: should not be the case, but should not crash parent application
                // if anything bad happens.
                if (!e || !e.data || !e.data.hasOwnProperty('code') || !e.data.preset) {
                    _setStatus("Internal error while saving.");
                    return;
                }
                const data:Object = e.data;
                const code:int = data.code;
                const preset:Preset = data.preset;
                const name:String = preset.name;
                _presetToPersist = preset;
            
                _manager.removeEventListener(PresetEvent.SET_COMPLETE, _onSaved);
            
                switch (code) {
                    case 1:
                        _setStatus("Preset saved: " + name);
                        _updateList();
                        break;
                    case 0:
                        _setStatus("Identical preset exists: " + name);
                        break;
                    case 2:
                        _setStatus("Updated preset: " + name);
                        _updateList();
                        break;
                }
            }
            
            /**
             * Executed when user clicks "Delete".
             */
            private function _onDeleteClick():void {
                if (!_manager || !presetList.selectedItem || presetList.selectedItem.readonly) {
                    return;
                }
                _manager.addEventListener(PresetEvent.DELETE_COMPLETE, _onDelOpExecuted);
                _manager.$deleteAsync(presetList.selectedItem);
            }
            
            /**
             * Executed when manager finished asynchronously deleting given preset.
             */
            private function _onDelOpExecuted(e:PresetEvent):void {
                _manager.removeEventListener(PresetEvent.DELETE_COMPLETE, _onDelOpExecuted);
                if (e.data && e.data.code === 1) {
                    _setStatus("Deleted preset: " + e.data.preset.name);
                    _updateList();
                    return;
                }
            
                // Safeguard: odds are remote, but let's cover that as well.
                _setStatus("Preset not found.");
            }
            
            /**
             * Executed when user causes the currently selected preset to change, either via
             * mouse or keyboard. Sends to the outer world the current Preset.
             */
            private function _onPresetChanged():void {
                if (!_manager) {
                    return;
                };
                if (presetList.selectedItem) {
            
                    // We only notify the outer world when an *existing* Preset has been selected.
                    // Otherwise, the user would be unable to save the content of existing Presets
                    // under new names (because entering the desired new name would instantly replace
                    // the existing preset's content with the new Preset's, which would be nill).
                    if (presetList.selectedIndex >= 0) {
                        dispatchEvent(new PresetEvent(PresetEvent.CHANGE, presetList.selectedItem, true));
                        _setStatus('Applied preset: ' + presetList.selectedItem.name);
                    }
                }
            
                _updateButtons();
            }
            
            /**
             * Called by the ComboBox component when it has been committed a free text that it
             * cannot resolve to an existing Preset. We transparently resolve the text to a Preset
             * and return it (to be later subjected to `_onPresetChanged`).
             */
            private function _labelToItem(input:String):* {
                if (!_manager) {
                    return;
                };
            
                // The manager errors on empty preset names, so we stop this short.
                input = _trim(input);
                if (!input) {
                    return null;
                }
            
                // Safeguard: maybe component wrongly saw an existing Preset's name as being new...
                const existingPreset:Preset = _manager.lookup(input, _rawPresets);
            
                return existingPreset || new Preset(input);
            }
        ]]>
    </fx:Script>

    <s:VGroup width="100%" gap="{getStyle('vGap') || 0}"
        padding="{getStyle('padding') || 0}"
        paddingLeft="{getStyle('paddingLeft') || 0}"
        paddingRight="{getStyle('paddingRight') || 0}"
        paddingTop="{getStyle('paddingTop') || 0}"
        paddingBottom="{getStyle('paddingBottom') || 0}">

        <s:Label text="{headerText}:"
            styleName="{getStyle('headerStyle')}"
            visible="{showHeader}"
            includeInLayout="{showHeader}"/>

        <s:HGroup width="100%" gap="{getStyle('hGap') || 0}">
            <s:ComboBox width="100%" id="presetList"
                maxChars="{_numChars}"
                prompt="{promptText}"
                dataProvider="{_presets}"
                labelField="name"
                labelToItemFunction="{_labelToItem}"
                change="_onPresetChanged()"/>

            <s:Button content="{saveButtonContent}"
                id="saveButton"
                styleName="{getStyle('saveButtonStyle')}"
                enabled="false"
                click="_onSaveClick()"/>

            <s:Button content="{deleteButtonContent}"
                id="deleteButton"
                styleName="{getStyle('deleteButtonStyle')}"
                enabled="false"
                click="_onDeleteClick()"/>

        </s:HGroup>

        <s:Label text="{_statusMsg}"/>
    </s:VGroup>
</s:Group>
